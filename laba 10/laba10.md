# Тема 10. 
Отчет по Теме #10 выполнил(а):
- Захаревич Анна Антоновна
- ИВТ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |


знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Навёрстка вы думаете, что декоратор – это какая-то бесполезная вещь, которая вам никогда не пригодится, но тут вдруг на паре по математике преподаватель просит всех посчитать число Фибоначчи для 100. Кто-то будет считать вручную (так точно не нужно), кто-то посчитает на калькуляторе, а кто-то понимает, что он самый крутой и напишет рекурсивную программу на Python и немного огорчится, потому что данная программа будет достаточно долго считаться, если ее просто так запускать. Но именно туда к вам на помощь придут декораторы, например @lru_cache (он предназначен для решения задач динамическим программированием, если простыми словами, то этот декоратор запоминает промежуточные результаты и при рекурсивном вызове функции программы не будет считать одни и те же значения, а просто "возвращать их из этого декоратора"). Вам нужно направить программу, которая будет считать числа Фибоначчи для 100 и запустить ее без этого декоратора и с ним, посмотреть на разницу во времени решения поставленной задачи. P.S. при запуске без декоратора может долго не ждать, для наглядности хватит 10 секунд ожидания.


```python

from functools import lru_cache

@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n-1)+fibonacci(n-2)

if __name__ == '__main__':
    print(fibonacci(100))




```
### Результат.

![image](https://github.com/user-attachments/assets/a92ed50a-f9c4-4424-a4b9-4d308b8c2f13)


## Выводы

Мы написали программу для рассчета числа Фибонначи с помощью декоратора @lru_cache

## Лабораторная работа №2
### Илья питает свой сайт и ему необходимо сделать минимальную проверку входа данных пользователей при регистрации. Для этого он реализовал функцию, которая выводит данные пользователя на экран и решает, что будет проверять правильность введенных данных при помощи декоратора, но в этом ему потребовалась ваша помощь. Напишите декоратор для функции, который будет принимать все параметры вызываемой функции (имя, возраст) и проверять чтобы возраст был больше 0 и меньше 130. Причём запомните, что важно сколько пользователь введет данных на сайт к Илье, будут обрабатываться только первые 2 аргумента.


```python

def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func
@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")
if __name__ == '__main__':
    personal_info('Владимир', 38)
    personal_info('Александр', -5)
    personal_info('Петр', 138, 15, 48, 2)




```
### Результат.
![image](https://github.com/user-attachments/assets/28a58728-b0b2-4313-8b35-d6ca45b7ce10)



## Выводы

Мы написали программу для проверки вводимых на сайт данных с помощью декоратора @check

## Лабораторная работа №3
###  Вам понадобилась идея Ильи с сайтом, и вы решили дальше работать вместе с ним. Но вот в вашем проекте появилась проблема, кто-то пытается сломать вашу функцию с получением данных для сайта. Эта функция работает только с данными integer, а какой-то недохакер пытается все сломать и вместо нужного типа данных отправляет string. Воспользуйтесь исключениями, чтобы неподходящий тип данных не ломал ваш сайт. Также дополнительно можете обернуть весь код функции в try/except/finally для того, чтобы программа вас осведомила о том, что ошибка или программа успешно выполнена.

```python

def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

if __name__ == '__main__':
    data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])


```
### Результат.

![image](https://github.com/user-attachments/assets/e6e69048-2861-416e-a52b-20b6492f6f38)



## Выводы

Эта программа проверяет наличие данных с неподходящим типом
  
## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное исключение, которое будет вызываться в случае, если в функцию проверки имени при регистрации передана строка длиннее десяти символов, а если имя имеет допустимую длину, то в консоль выводится "Успешная регистрация".

```python

class Car:
    def __init__(self, make, model):
        self.make = make # Защищенный атрибут
        self.model = model # Приватный атрибут
    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

my_car = Car('Toyota', 'Corolla')
print(my_car) # Доступ к защищенному аттрибуту"
# print(my_car._make) Ошибка! Защищенный аттрибт не доступен
my_car.drive()


```
### Результат.

![image](https://github.com/user-attachments/assets/00bf1a25-2984-412b-a623-2059ee98d4ed)



## Выводы
Эта программа позволяет сделать выводы об успешной регистрации исходя из допустимости вводимых данных

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логотер, для отслеживания его работы. Готовыми вариантами вы не заходили пользоваться, и поэтому решили создать очень простую паролию. Для этого создали две функции: init () (вызывается при создании класса декоратора в программе) и call () (вызывается при вызове декоратора). Создайте необходимый вам декоратор. Выведите все логи в консоль.

```python

class SiteChecker:
    def __init__(self, func):
        print('>Класс SiteChecker мктод __init__ успешный запуск')
        self.func = func
    def __call__(self):
        print('>Проверка перед запуском', self.func.__name__)
        self.func()
        print('>Проверка безопасного выыключения')

@SiteChecker
def site():
    print('Усердная работа сайта')

if __name__ == '__main__':
    print('>> Сайт запущен')
    site()
    print('>> Сайт выключен')



```
### Результат.

![image](https://github.com/user-attachments/assets/4bd4b831-a062-4d5a-827a-35cae05bfc8e)



## Выводы

В этом коде мы добавили логгер, испльзовав два декоратора



## Самостоятельная работа №1
### Воочка решил заняться спортивным программированием на Python, но для этого он должен знать за какое время выполняется его программа. Он решил, что для этого ему идеально подойдет декорратор для функции, который будет высчитывать за какое время выполнятся та или иная функция. Помогите Воочке в его начинаниях и напишите такой декоратор.
Пожазка: необходимо использовать модуль time
Результатом вашей работы будет листинг кода и скриншот консоли, в котором будет выполненная функция Фибоначчи и время выполнения программы. Также на этом примере можете посмотреть, что решение задачи через рекурсию не всегда является хорошей идеей. Поскольку решение Фибоначчи для 100 с использованием рекурсии и без динамического программирования решается гораздо легче секунды, а решение точно такой же задачи, но через цикл for еще и для 200, занимает меньше 1 секунды.

```python

import time

# Декоратор для измерения времени выполнения функции
def time_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()  # Начало отсчета времени
        result = func(*args, **kwargs)  # Вызов функции
        end_time = time.time()  # Конец отсчета времени
        print(f"Время выполнения функции '{func.__name__}': {end_time - start_time:.4f} секунд")
        return result
    return wrapper

# Функция для вычисления n-го числа Фибоначчи с использованием рекурсии
@time_decorator
def fibonacci_recursive(n):
    if n <= 1:
        return n
    else:
        return fibonacci_recursive(n-1) + fibonacci_recursive(n-2)

# Функция для вычисления n-го числа Фибоначчи с использованием цикла
@time_decorator
def fibonacci_iterative(n):
    a, b = 0, 1
    for _ in range(n):
        a, b = b, a + b
    return a

# Пример использования
n_recursive = 30  
print(f"Fibonacci (рекурсия) для {n_recursive}: {fibonacci_recursive(n_recursive)}")

n_iterative = 200 
print(f"Fibonacci (итеративный) для {n_iterative}: {fibonacci_iterative(n_iterative)}")




```
### Результат.
![image](https://github.com/user-attachments/assets/6ed35695-b767-4822-86c0-868a4f3edfbe)


## Выводы
1.	time_decorator: Это декоратор, который измеряет время выполнения функции и выводит его в консоль.
2.	fibonacci_recursive: Эта функция вычисляет n-е число Фибоначчи рекурсивным способом и заодно оборачивается в декоратор.
3.	fibonacci_iterative: Эта функция вычисляет n-е число Фибоначчи итеративным способом и тоже оборачивается в декоратор.
4.	Мы тестируем обе функции, вызывая их с разными значениями.


  
## Самостоятельная работа №2
### Посмотрев на Волчку, вы также заметили идеи спортивного программирования, начав тренировки вы узнали, что для решения некоторых задач необходимо считать данные из файлов. Но через некоторое время вы столкнулись с проблемой что файлы бывают пустыми, и вы не получаете входные данные для решения задачи. После этого вы решили не просто считать данные из файла, а всю конструкцию оборачивать в исключения, чтобы избежать такой проблемы. Создайте пустой файл и файл, в котором есть какая-то информация. Напишите код программы. Если файл пустой, то нужно вывести исключение ("бросить исключение") и вывести в консоль "файл пустой", а если он не пустой, то вывести информацию из файла.

```python

# Создание пустого файла
with open('empty_file.txt', 'w') as f:
    pass  # Просто создаем пустой файл

# Создание файла с данными
with open('data_file.txt', 'w') as f:
    f.write("Это файл с некоторой информацией.")



```

```python

def read_file(file_path):
    try:
        with open(file_path, 'r') as file:
            content = file.read()
            if not content:  # Проверяем, пустой ли файл
                raise ValueError("Файл пустой")  # Генерируем исключение, если файл пустой
            print(f"Содержимое файла '{file_path}':")
            print(content)  # Если файл не пустой, выводим его содержимое
    except FileNotFoundError:
        print(f"Ошибка: Файл '{file_path}' не найден.")
    except ValueError as ve:
        print(ve)  # Выводим сообщение об ошибке, если файл пустой
    except Exception as e:
        print(f"Произошла ошибка: {e}")

# Чтение пустого файла
read_file('empty_file.txt')

# Чтение файла с данными
read_file('data_file.txt')



```
### Результат.
![image](https://github.com/user-attachments/assets/c8e3daee-b30f-42c0-9430-1f62bc3e64ff)


## Выводы
Функция read_file принимает путь к файлу и пытается открыть его для чтения.
Если файл пустой, генерируется исключение ValueError.
Также обрабатываются исключения на случай, если файл не найден (FileNotFoundError) или любая другая ошибка (блок except Exception).
Если файл не пустой, его содержимое выводится в консоль.


## Самостоятельная работа №3
### Напишите функцию, которая будет складывать 2 и введенное пользователем число, но если пользователь введет строку или другой неподходящий тип данных, то в консоль выводится ошибка "Неподходящий тип данных. Ожидалось число." Реализовать функциональную программу необходимо через try/except и подобрать правильный тип исключения. Создавать собственное исключение нельзя. Проведите несколько тестов, в которых исключение вызывается и нет. Результатом выполнения задачи будет список кода и получившийся вывод в консоль

```python

def add_two_and_user_input():
    try:
        user_input = input("Введите число: ")  # Запрашиваем ввод от пользователя
        number = float(user_input)  # Пробуем привести ввод к типу float (число)
        result = 2 + number  # Складываем 2 с числом
        print(f"Результат: {result}")  # Выводим результат
    except ValueError:  # Обрабатываем ошибку, если ввод не является числом
        print("Неподходящий тип данных. Ожидалось число.")

# Тесты
if __name__ == "__main__":
    # Запускаем несколько тестов
    print("Тест 1:")
    add_two_and_user_input()  # Ожидается ввод числа, например 5

    print("\nТест 2:")
    add_two_and_user_input()  # Ожидается ввод строки, например "abc"

    print("\nТест 3:")
    add_two_and_user_input()  # Ожидается ввод числа с плавающей точкой, например 3.14

    print("\nТест 4:")
    add_two_and_user_input()  # Ожидается ввод пустой строки или пробелов




```
### Результат.
![image](https://github.com/user-attachments/assets/512951de-efc6-406d-b02f-9c8b05181d6f)


## Выводы
1.	Функция: add_two_and_user_input()запрашивает ввод у пользователя и пытается преобразовать его в число (тип float).
2.	Обработка исключений: Если ввод невозможно преобразовать (например, если введена строка, которая не является числом), возникает ValueError, и выводится сообщение об ошибке.


## Самостоятельная работа №4
### Создайте собственный декор для двух любых вашими придуманными функциями. Декораторы, которые использовались ранее в работе нельзя воссоздавать. Результатом выполнения задачи будет класс декоратора, две как-то связанных с ним функций, скриншот с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python

import time

class TimerDecorator:
    """
    Декоратор для измерения времени выполнения функции. 
    Сохраняет время начала выполнения перед вызовом функции, 
    а затем вычисляет время после и выводит разницу.
    """
    
    def __init__(self, func):
        self.func = func

    def __call__(self, *args, **kwargs):
        start_time = time.time()  # Сохраняем время начала выполнения
        result = self.func(*args, **kwargs)  # Вызываем декорируемую функцию
        end_time = time.time()  # Сохраняем время после выполнения
        duration = end_time - start_time  # Вычисляем время выполнения
        print(f"Время выполнения функции '{self.func.__name__}': {duration:.4f} секунд")
        return result

@TimerDecorator
def calculate_factorial(n):
    """
    Функция для вычисления факториала числа n.
    Использует рекурсивный подход.
    """
    if n == 0 or n == 1:
        return 1
    else:
        return n * calculate_factorial(n - 1)

@TimerDecorator
def fibonacci(n):
    """
    Функция для вычисления n-го числа Фибоначчи.
    Использует рекурсивный подход.
    """
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Примеры вызова функций
if __name__ == "__main__":
    # Вычисляем факториал числа 5
    print(f"Факториал 5: {calculate_factorial(5)}")

    # Вычисляем 10-е число Фибоначчи
    print(f"10-е число Фибоначчи: {fibonacci(10)}")



```
### Результат.
![image](https://github.com/user-attachments/assets/38e83f7b-cf96-4f0d-9b06-8828e7a76e9a)


## Выводы
Эта программа наглядно демонстрирует использование пользовательского декоратора и позволяет измерять время выполнения различных функций.

## Самостоятельная работа №5
### Создайте собственное исключение, которое будет использоваться в двух любых фрагментах кода. Исключения, которые использовались ранее в работе нельзя воспроизводить. Результатом выполнения задачи будет класс исключения, код к которому в двух местах используется это исключение, скрипт консоли с выполненной программой и подробные комментарии, которые будут описывать работу вашего кода.

```python

class InvalidInputError(Exception):
    """
    Исключение, которое будет вызываться при 
    недопустимом вводе данных в функции.
    """
    pass

def calculate_factorial(n):
    """
    Функция для вычисления факториала числа n.
    
    Вызывает InvalidInputError, если n отрицательное.
    """
    if n < 0:
        raise InvalidInputError(f"Факториал не определен для отрицательных чисел: {n}")
    if n == 0 or n == 1:
        return 1
    else:
        return n * calculate_factorial(n - 1)

def fibonacci(n):
    """
    Функция для вычисления n-го числа Фибоначчи.
    
    Вызывает InvalidInputError, если n отрицательное.
    """
    if n < 0:
        raise InvalidInputError(f"Число Фибоначчи не определено для отрицательных индексов: {n}")
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

# Основной блок программы

if __name__ == "__main__":
    # Пример использования функции calculate_factorial
    try:
        num = int(input("Введите число для вычисления факториала: "))
        result = calculate_factorial(num)
        print(f"Факториал {num} = {result}")
    except InvalidInputError as e:
        print(f"Ошибка: {e}")

    # Пример использования функции fibonacci
    try:
        index = int(input("Введите индекс для вычисления числа Фибоначчи: "))
        result = fibonacci(index)
        print(f"{index}-е число Фибоначчи = {result}")
    except InvalidInputError as e:
        print(f"Ошибка: {e}")



```
### Результат.
![image](https://github.com/user-attachments/assets/51e3e274-08e3-4ddb-be4b-3e396f9df80c)


## Выводы
Я создадла собственное исключение InvalidInputError, которое будет возникать в следующих двух случаях:
1.	Когда пользователь пытается передать некорректные данные в функцию для вычисления факториала (например, отрицательное число).
2.	Когда пользователь пытается вычислить число Фибоначчи для отрицательного индекса.

### Общие выводы 
в этой лабораторной работе я разобралась в использовании декораторов, их функциях, случаях применения. Самостоятельно решила несколько задач с использованием различных декораторов 
  


## Общие выводы по теме
### Выполняя данную работу я вспомнила основные функции Python, синтаксис этого языка. В задачах этой работы используются простейшие операции, необходимые для присваивания значений, вывода этих значений и их изменения.
